{
  "hash": "a52fec538ce66a766ac5bf963c7ea7b1",
  "result": {
    "markdown": "---\ntitle: \"Clustering\"\nauthor: \"Aadyant Khatri\"\ndate: \"2023-12-05\"\ncategories: [clustering, code, analysis, ML]\nimage: \"image.jpg\"\n---\n\n\n# Clustering\n\nClustering involves organizing a set of items so that those within the same group (called a cluster) are more alike to each other than to those in different groups. It is frequently employed by data experts during exploratory data analysis to uncover fresh insights and trends within data. Since clustering falls under unsupervised machine learning, it operates without the need for labeled datasets.\n\nClustering, in contrast to supervised learning tasks like classification or regression, lacks a complete end-to-end automation capability. Instead, it involves an iterative process of uncovering information that necessitates expertise in the field and frequent human judgment for adjusting both data and model parameters to achieve the desired outcomes.\n\nCrucially, because clustering operates on unsupervised learning principles and doesn't rely on labeled data, it's impossible to compute performance metrics like accuracy, AUC, RMSE, etc., for comparing various algorithms or data preprocessing methods. Consequently, evaluating clustering models becomes notably challenging and subjective.\n\nThe primary benchmarks for successful clustering models revolve around:\n\n-   Is the model interpretable?\n-   Does the clustering output contribute to business utility?\n-   Have novel insights or previously undiscovered patterns in the data been revealed through clustering?\n\nBefore diving into algorithmic details, let's first develop a basic understanding of clustering by employing a simplified example involving a dataset of various fruits. Suppose we possess a large assortment of images featuring three types of fruits: strawberries, pears, and apples.\n\nWithin this dataset, the images are jumbled together, and the objective is to categorize similar fruits into three distinct groups, with each group exclusively containing one type of fruit. This is exactly what a clustering algorithm will do.\n\n![](merge3cluster.jpg){fig-align=\"center\"}\n\nThe initial phase of any clustering algorithm involves establishing a measure of distance between individual observations or sets of observations. Subsequently, determining the method to unite these observations into clusters becomes essential. Various algorithms exist for this purpose, with hierarchical and k-means being two such examples.\n\nTo illustrate this process, we will create a basic scenario using movie ratings. Specifically, we'll generate a matrix, `x`, containing ratings for the top 50 movies based on the highest number of ratings received. The 50 movies are as follows:\n\n\n\n\n::: {.cell fold='true'}\n\n```{.r .cell-code}\ndata(\"movielens\")\ntop <- movielens |>\n  group_by(movieId) |>\n  summarize(n=n(), title = first(title)) |>\n  top_n(50, n) |>\n  pull(movieId)\n\nx <- movielens |> \n  filter(movieId %in% top) |>\n  group_by(userId) |>\n  filter(n() >= 25) |>\n  ungroup() |> \n  select(title, userId, rating) |>\n  spread(userId, rating)\n\nrow_names <- str_remove(x$title, \": Episode\") |> str_trunc(20)\nx <- x[,-1] |> as.matrix()\nx <- sweep(x, 2, colMeans(x, na.rm = TRUE))\nx <- sweep(x, 1, rowMeans(x, na.rm = TRUE))\nrownames(x) <- row_names\n\nrow_names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Ace Ventura: Pet ...\" \"Aladdin\"              \"American Beauty\"     \n [4] \"Apollo 13\"            \"Back to the Future\"   \"Batman\"              \n [7] \"Beauty and the Beast\" \"Braveheart\"           \"Dances with Wolves\"  \n[10] \"Dumb & Dumber (Du...\" \"E.T. the Extra-Te...\" \"Fargo\"               \n[13] \"Fight Club\"           \"Forrest Gump\"         \"Fugitive, The\"       \n[16] \"Gladiator\"            \"Godfather, The\"       \"Good Will Hunting\"   \n[19] \"Groundhog Day\"        \"Independence Day ...\" \"Jurassic Park\"       \n[22] \"Lion King, The\"       \"Lord of the Rings...\" \"Lord of the Rings...\"\n[25] \"Lord of the Rings...\" \"Mask, The\"            \"Matrix, The\"         \n[28] \"Men in Black (a.k...\" \"Mission: Impossible\"  \"Princess Bride, The\" \n[31] \"Pulp Fiction\"         \"Raiders of the Lo...\" \"Saving Private Ryan\" \n[34] \"Schindler's List\"     \"Seven (a.k.a. Se7en)\" \"Shawshank Redempt...\"\n[37] \"Shrek\"                \"Silence of the La...\" \"Sixth Sense, The\"    \n[40] \"Speed\"                \"Star Wars IV - A ...\" \"Star Wars V - The...\"\n[43] \"Star Wars VI - Re...\" \"Terminator 2: Jud...\" \"Terminator, The\"     \n[46] \"Titanic\"              \"Toy Story\"            \"True Lies\"           \n[49] \"Twelve Monkeys (a...\" \"Usual Suspects, The\" \n```\n:::\n:::\n\n\nWe aim to utilize this data to identify potential groups or clusters of movies by analyzing the ratings given by 139 movie reviewers. Our initial approach involves determining the distance between every pair of movies using the `dist` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- dist(x)\n```\n:::\n\n\n## Hierarchical clustering\n\nAfter calculating the distance between every pair of movies, we require a method to create clusters based on this information. Hierarchical clustering begins by treating each movie as its own cluster. Subsequently, it progressively merges the two closest clusters together until eventually forming a single cluster containing all movies. The `hclust` function executes this process and requires a distance measure as its input. A dendrogram allows us to observe the groups that have emerged as a result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh <- hclust(d)\nplot(h, cex = 0.65, main = \"\", xlab = \"\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nThis chart provides an estimation of the distance separating any two films. This distance is determined by identifying the first point, from top to bottom, where the movies diverge into distinct categories. The vertical position of this point indicates the gap between these groups. For instance, the distance between the three Star Wars movies is 8 units or fewer, while the gap between Raiders of the Lost Ark and Silence of the Lambs is approximately 17.\n\nTo establish specific groups, there are two approaches:\n\n-   specifying a minimum required distance for observations to belong to the same group, or\n\n-   determining the desired number of groups and then identifying the minimum distance that accomplishes this.\n\nThe function `cutree` can be applied to the outcome of `hclust` to execute either of these methods and create distinct groups.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- cutree(h, k = 10)\n```\n:::\n\n\nObserve that the clustering offers valuable understanding regarding different movie categories. Group 4 seems to consist of blockbuster films:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(groups)[groups==4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Apollo 13\"            \"Braveheart\"           \"Dances with Wolves\"  \n[4] \"Forrest Gump\"         \"Good Will Hunting\"    \"Saving Private Ryan\" \n[7] \"Schindler's List\"     \"Shawshank Redempt...\"\n```\n:::\n:::\n\n\nGroup 9 seems to consist of films that cater to nerdy or geeky interests:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(groups)[groups==9]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Lord of the Rings...\" \"Lord of the Rings...\" \"Lord of the Rings...\"\n[4] \"Star Wars IV - A ...\" \"Star Wars V - The...\" \"Star Wars VI - Re...\"\n```\n:::\n:::\n\n\n## k-means clustering\n\nIn order to employ the k-means clustering technique, it's essential to pre-specify the number of clusters `k`, that we aim to establish. The k-means algorithm is iterative. Initially, `k` centers are designated. Subsequently, every data point is allocated to the cluster whose center is nearest to that particular data point. Then, in the following step, the centers are re-calibrated using the observations within each cluster, where the average values for each feature are utilized to establish a centroid. These two steps are reiterated until the the centers converge. The different can be visualized below\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- kmeans(x_0, centers = 10)\ngroups <- k$cluster\n\nplotcluster(x_0, groups)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n# Applications\n\nClustering stands as an immensely potent method applicable across diverse sectors, including media, healthcare, manufacturing, and service industries, utilized wherever substantial datasets are involved. Let's explore a few real-life scenarios to illustrate its practical applications:\n\n## Customer Segmentation\nConsumers are grouped based on clustering algorithms that analyze their buying patterns or preferences, aiming to create targeted marketing strategies. For instance, when faced with a vast customer base like 10 million individuals, rather than crafting an impractical number of 10 million distinct marketing campaigns, clustering could be employed to condense these customers into 25 clusters, allowing for the creation of 25 tailored marketing campaigns instead.\n\n\n## Retail Clustering\nNumerous opportunities exist for clustering within retail operations. One approach involves collecting store-specific data and clustering it to identify similarities among stores based on factors such as foot traffic, average sales, and product variety. For instance, by grouping stores based on these attributes, insights can be derived regarding which locations share similarities.\n\n## Image Segmentation\nImage segmentation involves categorizing an image into distinct groups, and extensive studies have focused on employing clustering techniques within this field. This clustering method proves beneficial when aiming to separate objects within an image for individual analysis and identification purposes.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}